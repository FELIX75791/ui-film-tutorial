<!-- templates/quiz_question.html -->
<!-- linlinzhang -->
{% extends "base.html" %}

{% block title %}Question {{ current_question }} - Quiz{% endblock %}

{% block head %}
<style>
    /* Quiz container styles */
    .quiz-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
        background-color: #ffffff;
        border-radius: 16px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    }

    /* Question header styles */
    .question-header {
        margin-bottom: 2rem;
        padding: 1.5rem;
        background-color: #f8fafc;
        border-radius: 12px;
    }

    .question-header h1 {
        font-size: 1.8rem;
        color: #1e293b;
        margin-bottom: 1rem;
        font-weight: 600;
    }

    .question-header h2 {
        font-size: 1.4rem;
        color: #334155;
        margin-bottom: 1rem;
    }

    .question-header p {
        color: #475569;
        font-size: 1.1rem;
        line-height: 1.5;
    }

    /* Quiz content area */
    .quiz-content {
        background-color: #ffffff;
        padding: 2rem;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    /* Options grid for checkbox/radio questions */
    .options-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 1rem;
        margin: 1.5rem 0;
    }

    .option {
        background-color: #f8fafc;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        transition: all 0.2s ease;
        border: 1px solid #e2e8f0;
    }

    .option:hover {
        background-color: #f1f5f9;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .option input[type="checkbox"],
    .option input[type="radio"] {
        width: 18px;
        height: 18px;
        accent-color: #4f46e5;
    }

    .option span {
        color: #334155;
        font-size: 1rem;
        font-weight: 500;
    }

    /* Question media */
    .question-media {
        margin: 1.5rem 0;
        text-align: center;
        background-color: #f8fafc;
        padding: 1.5rem;
        border-radius: 12px;
    }

    .question-media img {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* Navigation buttons */
    .button-container {
        margin-top: 2rem;
        padding: 1.5rem;
        background-color: #f8fafc;
        border-radius: 12px;
        border: 1px solid #e2e8f0;
    }

    .nav-buttons {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
    }

    .btn {
        display: inline-block;
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        text-align: center;
        min-width: 120px;
    }

    .btn-primary {
        background-color: #4f46e5;
        color: white;
        box-shadow: 0 2px 4px rgba(79, 70, 229, 0.2);
    }

    .btn-primary:hover:not(:disabled) {
        background-color: #4338ca;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(79, 70, 229, 0.25);
    }

    .btn-secondary {
        background-color: #f1f5f9;
        color: #475569;
        border: 1px solid #e2e8f0;
    }

    .btn-secondary:hover:not(:disabled) {
        background-color: #e2e8f0;
        color: #334155;
        transform: translateY(-1px);
    }

    /* Feedback message */
    .quiz-feedback {
        margin-top: 1.5rem;
        padding: 1.5rem;
        border-radius: 8px;
        background-color: #ffffff;
        border: 1px solid;
        animation: fadeIn 0.3s ease;
    }

    .quiz-feedback.success {
        background-color: #f0fdf4;
        border-color: #86efac;
        color: #166534;
    }

    .quiz-feedback.error {
        background-color: #fef2f2;
        border-color: #fecaca;
        color: #991b1b;
    }

    .quiz-feedback h3 {
        font-size: 1.2rem;
        margin-bottom: 0.5rem;
        font-weight: 600;
    }

    .quiz-feedback p {
        font-size: 1rem;
        line-height: 1.5;
    }

    /* Help text for correct answers */
    .help-text {
        margin-top: 1rem;
        padding: 1rem;
        background-color: #f8fafc;
        border-radius: 8px;
        color: #475569;
        font-size: 0.9rem;
        line-height: 1.4;
        border-left: 3px solid #4f46e5;
    }

    /* Matching question styles */
    .matching-container {
        display: flex;
        justify-content: space-between;
        gap: 2rem;
        margin: 2rem 0;
        background-color: #f5f5f5;
        padding: 2rem;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .matching-column {
        flex: 1;
        background-color: #ffffff;
        padding: 1.5rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .matching-column h3 {
        color: #333;
        text-align: center;
        margin-bottom: 1.5rem;
        font-size: 1.2rem;
        font-weight: 600;
    }
    
    #tech-list .technique-item {
        background-color: #eef2ff;
        padding: 1rem 1.5rem;
        margin-bottom: 0.8rem;
        border-radius: 8px;
        cursor: move;
        user-select: none;
        transition: all 0.2s ease;
        color: #4338ca;
        border: 1px solid #e0e7ff;
        font-weight: 500;
    }
    
    .technique-item:hover {
        background-color: #e0e7ff;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(67, 56, 202, 0.1);
    }
    
    .technique-item.ui-draggable-dragging {
        opacity: 0.9;
        transform: scale(1.05);
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(67, 56, 202, 0.15);
    }
    
    .emotion-box {
        background-color: #f8fafc;
        padding: 1rem 1.5rem;
        margin-bottom: 0.8rem;
        border-radius: 8px;
        min-height: 60px;
        border: 2px dashed #cbd5e1;
        transition: all 0.2s ease;
        display: flex;
        flex-direction: column;
        justify-content: center;
        color: #64748b;
    }
    
    .emotion-box.ui-droppable-active {
        border-color: #818cf8;
        background-color: #f5f3ff;
    }
    
    .emotion-box.ui-droppable-hover {
        background-color: #ede9fe;
        border-color: #6366f1;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.15);
    }
    
    .emotion-box .technique-item {
        width: 100%;
        margin-bottom: 0;
    }
    
    /* Style for the emotion labels */
    .emotion-label {
        background-color: #e0e7ff;
        color: #4338ca;
        padding: 0.5rem;
        border-radius: 4px;
        font-weight: 500;
        margin-top: 0.5rem;
        text-align: center;
        font-size: 0.9rem;
        border: 1px solid #c7d2fe;
    }
    
    /* Adjust placeholder position */
    .emotion-box .placeholder {
        margin-bottom: 0.5rem;
    }
</style>

<script type="text/javascript">
    // Initialize quiz state from template variables
    var quizProgress = {{ quiz_progress|tojson|safe if quiz_progress else '{}' }};
    var currentQuestion = {{ current_question }};
    var totalQuestions = {{ total_questions }};
    
    document.addEventListener('DOMContentLoaded', function() {
        window.QUIZ_STATE = {
            progress: quizProgress,
            currentQuestion: currentQuestion,
            totalQuestions: totalQuestions
        };
    });
</script>

<script>
// Add this at the start of your script section to define current question ID 
// as a global variable that can be used throughout your scripts
const currentQuestionId = {{ current_question }};

document.addEventListener('DOMContentLoaded', function() {
  console.log("Restoring saved answers if any");
  
  // Get answers from server-provided data
  const saved = {{ saved_answer|tojson|safe if saved_answer else 'null' }};
  
  if (!saved) {
    console.log("No saved answer found");
    return;
  }
  
  console.log("Found saved answer:", saved);
  
  const type = document.querySelector('.quiz-content').dataset.questionType;
  if (type === 'scenario') {
    // single radio
    console.log("Restoring scenario answer:", saved);
    const r = document.querySelector(`input[type="radio"][value="${saved}"]`);
    if (r) {
      r.checked = true;
      console.log("Restored radio selection:", saved);
    }
  }
  else if (type === 'identify' || type === 'analysis') {
    // multiple checkboxes
    console.log("Restoring identify/analysis answers:", saved);
    if (Array.isArray(saved)) {
      saved.forEach(val => {
        const cb = document.querySelector(`input[type="checkbox"][value="${val}"]`);
        if (cb) {
          cb.checked = true;
          console.log("Restored checkbox:", val);
        }
      });
    }
  }
  else if (type === 'match') {
    // drag-and-drop: move each technique into the saved emotion box
    console.log("Restoring match answers:", saved);
    
    // Clear existing items first to avoid duplicates
    document.querySelectorAll('.emotion-box').forEach(box => {
      // Remove any technique items
      const existingItem = box.querySelector('.technique-item');
      if (existingItem) {
        existingItem.remove();
      }
      
      // Ensure placeholder is visible in empty boxes, but don't remove emotion label
      if (!box.querySelector('.placeholder')) {
        const placeholder = document.createElement('span');
        placeholder.className = 'placeholder';
        placeholder.textContent = 'Drop technique here';
        
        const emotionLabel = box.querySelector('.emotion-label');
        if (emotionLabel) {
          box.insertBefore(placeholder, emotionLabel);
        } else {
          box.appendChild(placeholder);
        }
      }
    });
    
    // First, make sure all technique items are in the tech-list
    const techList = document.getElementById('tech-list');
    document.querySelectorAll('.technique-item').forEach(item => {
      // If not already in the tech-list, move it there
      const parent = item.parentElement;
      if (parent && parent.id !== 'tech-list') {
        techList.appendChild(item);
      }
    });
    
    // Now restore saved matches
    if (saved && typeof saved === 'object') {
      Object.entries(saved).forEach(([tech, emo]) => {
        // Find the technique item in the DOM
        const item = document.querySelector(`.technique-item[data-technique="${tech}"]`);
        const box = document.querySelector(`.emotion-box[data-emotion="${emo}"]`);
        
        if (item && box) {
          // Remove placeholder if present
          const placeholder = box.querySelector('.placeholder');
          if (placeholder) {
            placeholder.remove();
          }
          
          // Move item to box, before the emotion label
          const emotionLabel = box.querySelector('.emotion-label');
          if (emotionLabel) {
            box.insertBefore(item, emotionLabel);
          } else {
            box.appendChild(item);
          }
          
          item.style.position = 'relative';
          console.log(`Restored match: ${tech} → ${emo}`);
        } else {
          console.warn(`Could not find elements for match: ${tech} → ${emo}`);
          console.log("Available techniques:", Array.from(document.querySelectorAll('.technique-item')).map(el => el.dataset.technique));
          console.log("Available emotions:", Array.from(document.querySelectorAll('.emotion-box')).map(el => el.dataset.emotion));
        }
      });
    }
    
    // Re-initialize drag and drop for any remaining items
    if (typeof $ !== 'undefined') {
      console.log("Re-initializing drag and drop");
      $('.technique-item').draggable({
        revert: 'invalid',
        helper: 'clone',
        cursor: 'move',
        start: function(event, ui) {
          $(this).addClass('dragging');
        },
        stop: function(event, ui) {
          $(this).removeClass('dragging');
          setTimeout(saveCurrentSelections, 100);
        }
      });
      
      $('.emotion-box').droppable({
        accept: '.technique-item',
        hoverClass: 'ui-droppable-hover',
        drop: function(event, ui) {
          const $droppedItem = ui.draggable;
          const $dropZone = $(this);
          
          // If there's already an item in this box, move it back
          const $existingItem = $dropZone.find('.technique-item');
          if ($existingItem.length) {
            $('#tech-list').append($existingItem);
          }
          
          // Remove placeholder text
          $dropZone.find('.placeholder').remove();
          
          // Move dropped item to this box
          $droppedItem.appendTo($dropZone);
          $droppedItem.css({
            top: 0,
            left: 0,
            position: 'relative'
          });
          
          // Auto-save after drop
          setTimeout(saveCurrentSelections, 100);
        }
      });
    }
  }
  
  // Check if this question was already submitted (not just auto-saved)
  const wasSubmitted = {{ is_submitted|tojson|safe }};
  
  console.log("Is question submitted:", wasSubmitted);
  console.log("Question ID:", currentQuestionId);
  console.log("Saved answer:", saved);
  
  // Only show feedback if the answer was actually submitted
  if (wasSubmitted) {
    // Get question data
    const questionData = {{ question|tojson|safe }};
    let isCorrect = false;
    
    // Determine if answer was correct
    if (type === 'scenario') {
      isCorrect = saved === questionData.correct_answer;
    } else if (type === 'match' && typeof saved === 'object') {
      const userKeys = Object.keys(saved);
      const correctKeys = Object.keys(questionData.correct_answers);
      isCorrect = (
        userKeys.length === correctKeys.length &&
        userKeys.every(key => saved[key] === questionData.correct_answers[key])
      );
    } else if ((type === 'identify' || type === 'analysis') && Array.isArray(saved)) {
      // Sort both arrays for comparison
      const sortedUserAnswers = [...saved].sort();
      const sortedCorrectAnswers = [...questionData.correct_answers].sort();
      isCorrect = arraysEqual(sortedUserAnswers, sortedCorrectAnswers);
    }
    
    // Show feedback
    const feedbackDiv = document.getElementById('feedback');
    const submitBtn = document.getElementById('submit-btn');
    const nextBtn = document.getElementById('next-btn');
    
    if (feedbackDiv && submitBtn && nextBtn) {
      // Clear any existing feedback content first
      feedbackDiv.innerHTML = '';
      
      // Display feedback
      feedbackDiv.style.display = 'block';
      feedbackDiv.className = `quiz-feedback ${isCorrect ? 'success' : 'error'}`;
      feedbackDiv.innerHTML = `
        <h3>${isCorrect ? '✓ Correct!' : '✗ Incorrect'}</h3>
        <p>${isCorrect ? 
            'Great job! You can proceed to the next question.' : 
            'Not quite right. ' + questionData.explanation}</p>
      `;
      
      // Add a single help text element with the correct answers
      const helpText = document.createElement('div');
      helpText.className = 'help-text';
      // Get the correct answer data directly from question
      if (questionData.type === 'scenario') {
        // For scenario questions, use correct_answer
        helpText.innerHTML = `
          <strong>Correct Answer:</strong><br>
          ${questionData.correct_answer}<br><br>
          <strong>Explanation:</strong><br>
          ${questionData.explanation}
        `;
      } else if (questionData.type === 'match') {
        // For match questions, format the object
        const formattedMatches = Object.entries(questionData.correct_answers)
          .map(([k, v]) => `${k} → ${v}`)
          .join('<br>');
        helpText.innerHTML = `
          <strong>Correct Answer:</strong><br>
          ${formattedMatches}<br><br>
          <strong>Explanation:</strong><br>
          ${questionData.explanation}
        `;
      } else {
        // For identify or analysis, use correct_answers array
        helpText.innerHTML = `
          <strong>Correct Answer:</strong><br>
          ${questionData.correct_answers.join(', ')}<br><br>
          <strong>Explanation:</strong><br>
          ${questionData.explanation}
        `;
      }
      feedbackDiv.appendChild(helpText);
      
      // Update button states
      submitBtn.disabled = true;
      nextBtn.style.display = 'inline-block';
    }
  } else {
    console.log("Answer was auto-saved but not submitted yet");
  }
});
</script>


<script src="{{ url_for('static', filename='js/quiz.js') }}"></script>

<!-- Add jQuery UI for better drag and drop support -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>
<link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
{% endblock %}

{% block content %}
<div class="quiz-container">
    <div class="question-header">
        <h1>Question {{ current_question }} of {{ total_questions }}</h1>
        <h2>{{ question.title }}</h2>
        <p class="lead">{{ question.question }}</p>
    </div>
    
    <div class="quiz-content" data-question-type="{{ question.type }}">
        {% if question.image %}
        <div class="question-media">
            <img src="{{ url_for('static', filename=question.image) }}" alt="Quiz Question">
        </div>
        {% elif question.media and question.media.type == 'video' %}
        <div class="question-media">
            <video controls style="max-width:100%; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.1);">
                <source src="{{ question.media.src }}" type="video/mp4">
                Your browser does not support the video tag.
            </video>
        </div>
        {% endif %}
        
        <form id="question-form" class="quiz-form" onsubmit="return false;">
            {% if question.type in ['identify', 'analysis'] %}
                <div class="options-grid">
                    {% for option in question.options %}
                    <label class="option-label">
                        <input type="checkbox" 
                               name="answer" 
                               value="{{ option }}"
                               {% if saved_answer and option in saved_answer %}checked{% endif %}>
                        {{ option }}
                    </label>
                    {% endfor %}
                </div>
            {% elif question.type == 'scenario' %}
                <div class="scenario-options">
                    {% for option in question.options %}
                    <label class="scenario-option">
                        <input type="radio" 
                               name="answer" 
                               value="{{ option }}"
                               {% if saved_answer == option %}checked{% endif %}>
                        {{ option }}
                    </label>
                    {% endfor %}
                </div>
            {% elif question.type == 'match' %}
                <div class="matching-container">
                    <div class="matching-column">
                        <h3>Techniques</h3>
                        <div id="tech-list">
                            {% for tech in question.techniques %}
                            <div class="technique-item" data-technique="{{ tech }}">{{ tech }}</div>
                            {% endfor %}
                        </div>
                    </div>
                    <div class="matching-column">
                        <h3>Effects</h3>
                        {% for emotion in question.emotions %}
                        <div class="emotion-box" data-emotion="{{ emotion }}">
                            <span class="placeholder">Drop technique here</span>
                            <div class="emotion-label">{{ emotion }}</div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            {% endif %}
            
            <div class="button-container">
                <div class="nav-buttons">
                    <div class="left-buttons">
                        {% if current_question > 1 %}
                        <a href="/quiz/{{ current_question - 1 }}" class="btn btn-secondary">Previous</a>
                        {% else %}
                        <button type="button" class="btn btn-secondary" disabled>Previous</button>
                        {% endif %}
                    </div>
                    
                    <div class="center-buttons">
                        <button type="button" id="submit-btn" class="btn btn-primary">Submit Answer</button>
                        <button type="button" id="reset-btn" class="btn btn-secondary" style="margin-left: 10px;">Reset Answer</button>
                        {% if current_question < total_questions %}
                        <a href="/quiz/{{ current_question + 1 }}" id="next-btn" class="btn btn-secondary" style="display: none;">Next Question</a>
                        {% else %}
                        <a href="/quiz/results" id="next-btn" class="btn btn-secondary" style="display: none;">Finish Quiz</a>
                        {% endif %}
                    </div>
                </div>
            </div>
        </form>
        
        <div id="feedback" class="quiz-feedback" style="display: none;">
            <h3></h3>
            <p></p>
        </div>
    </div>
</div>

<!-- Hidden element to store quiz progress -->
<script id="quiz-progress" type="application/json">
    {{ quiz_progress|tojson|safe }}
</script>

<script>
// Define arraysEqual function that's used in the submit handler
function arraysEqual(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) return false;
    if (a.length !== b.length) return false;
    
    // Sort arrays to ensure consistent comparison
    const sortedA = [...a].sort();
    const sortedB = [...b].sort();
    
    return sortedA.every((val, index) => val === sortedB[index]);
}

// Function to save answers in real-time without waiting for submit
function saveCurrentSelections() {
    // Get selected answers based on question type
    let answers;
    const questionType = document.querySelector('.quiz-content').dataset.questionType;
    const currentQuestion = {{ current_question }};
    
    if (questionType === 'scenario') {
        const selectedRadio = document.querySelector('input[type="radio"]:checked');
        answers = selectedRadio ? selectedRadio.value : null;
    } else if (questionType === 'identify' || questionType === 'analysis') {
        answers = Array.from(document.querySelectorAll('input[type="checkbox"]:checked'))
            .map(input => input.value);
    } else if (questionType === 'match') {
        answers = {};
        document.querySelectorAll('.emotion-box').forEach(box => {
            const technique = box.querySelector('.technique-item')?.dataset.technique;
            if (technique) {
                answers[technique] = box.dataset.emotion;
            }
        });
    }
    
    // Only save if we have selections
    if ((Array.isArray(answers) && answers.length > 0) || 
        (typeof answers === 'object' && Object.keys(answers).length > 0) ||
        (typeof answers === 'string')) {
        
        console.log("Auto-saving current selections:", answers);
        
        // Special case for question 1
        if (currentQuestion === 1) {
            console.log("Auto-saving Question 1:", answers);
        }
        
        // Save progress to session with a flag indicating it's only a draft (not submitted)
        fetch('/save_progress', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                answers: {
                    [currentQuestion]: answers
                },
                submitted: false  // Add submitted flag = false
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log("Auto-save response:", data);
            
            // Special verification for question 1
            if (currentQuestion === 1) {
                console.log("Auto-save confirmation for Q1:", data);
            }
        })
        .catch(error => {
            console.error('Error auto-saving selections:', error);
        });
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const submitBtn = document.getElementById('submit-btn');
    const nextBtn = document.getElementById('next-btn');
    const resetBtn = document.getElementById('reset-btn');
    const feedbackDiv = document.getElementById('feedback');
    
    // Add event listeners to automatically save when users make selections
    
    // For checkbox questions (identify/analysis)
    document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', saveCurrentSelections);
    });
    
    // For radio button questions (scenario)
    document.querySelectorAll('input[type="radio"]').forEach(radio => {
        radio.addEventListener('change', saveCurrentSelections);
    });
    
    // For matching questions - save after drag and drop
    if (typeof $ !== 'undefined') {
        $('.emotion-box').on('drop', function(event, ui) {
            // Allow a brief delay for the DOM to update after drop
            setTimeout(saveCurrentSelections, 100);
        });
    }
    
    // Reset button functionality
    if (resetBtn) {
        resetBtn.addEventListener('click', function() {
            const currentQuestion = {{ current_question }};
            
            // Reset checkboxes
            document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
            
            // Reset radio buttons
            document.querySelectorAll('input[type="radio"]').forEach(rb => {
                rb.checked = false;
            });
            
            // Reset matching elements
            const type = document.querySelector('.quiz-content').dataset.questionType;
            if (type === 'match') {
                // Move all technique items back to the tech-list
                const techList = document.getElementById('tech-list');
                document.querySelectorAll('.technique-item').forEach(item => {
                    techList.appendChild(item);
                    item.style.position = '';
                });
                
                // Restore placeholders
                document.querySelectorAll('.emotion-box').forEach(box => {
                    if (!box.querySelector('.placeholder')) {
                        const placeholder = document.createElement('span');
                        placeholder.className = 'placeholder';
                        placeholder.textContent = 'Drop technique here';
                        box.appendChild(placeholder);
                    }
                });
                
                // Reinitialize drag and drop
                if (typeof $ !== 'undefined') {
                    $('.technique-item').draggable({
                        revert: 'invalid',
                        helper: 'clone',
                        cursor: 'move',
                        stop: function(event, ui) {
                            // Auto-save after drag
                            setTimeout(saveCurrentSelections, 100);
                        }
                    });
                }
            }
            
            // Reset feedback
            if (feedbackDiv) {
                feedbackDiv.style.display = 'none';
                feedbackDiv.innerHTML = '';
            }
            
            // Enable submit button
            if (submitBtn) {
                submitBtn.disabled = false;
            }
            
            // Hide next button
            if (nextBtn) {
                nextBtn.style.display = 'none';
            }
            
            // Clear answer from server
            fetch('/save_progress', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    answers: {
                        [currentQuestionId]: null
                    }
                })
            });
        });
    }
    
    if (submitBtn) {
        submitBtn.addEventListener('click', function(e) {
            e.preventDefault();
            
            // Get selected answers based on question type
            let answers;
            const questionType = document.querySelector('.quiz-content').getAttribute('data-question-type');
            
            if (questionType === 'scenario') {
                const selectedRadio = document.querySelector('input[type="radio"]:checked');
                answers = selectedRadio ? selectedRadio.value : null;
            } else if (questionType === 'identify' || questionType === 'analysis') {
                answers = Array.from(document.querySelectorAll('input[type="checkbox"]:checked'))
                    .map(input => input.value);
            } else if (questionType === 'match') {
                answers = {};
                document.querySelectorAll('.emotion-box').forEach(box => {
                    const technique = box.querySelector('.technique-item')?.dataset.technique;
                    if (technique) {
                        answers[technique] = box.dataset.emotion;
                    }
                });
            }
            
            // Special handling for question 1
            if (currentQuestion === 1) {
                console.log("Submitting Question 1:", answers);
            }
            
            // Get correct answers from the question data
            const questionData = {{ question|tojson|safe }};
            let isCorrect = false;
            
            if (questionType === 'scenario') {
                isCorrect = answers === questionData.correct_answer;
            } else if (questionType === 'match') {
                // Compare dictionaries by their contents
                const userKeys = Object.keys(answers);
                const correctKeys = Object.keys(questionData.correct_answers);
                isCorrect = (
                    userKeys.length === correctKeys.length &&
                    userKeys.every(key => 
                        answers[key] === questionData.correct_answers[key]
                    )
                );
            } else if (questionType === 'identify' || questionType === 'analysis') {
                isCorrect = arraysEqual(answers.sort(), questionData.correct_answers.sort());
            }
            
            // Make the submission request
            const submitData = {
                answers: {
                    [currentQuestion]: answers
                },
                submitted: true  // Always set submitted flag to true
            };
            
            console.log("Sending submission data:", submitData);
            
            // Save progress and show feedback
            fetch('/save_progress', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(submitData)
            })
            .then(response => response.json())
            .then((data) => {
                console.log("Save response:", data);
                
                // Clear any existing feedback content first
                feedbackDiv.innerHTML = '';
                
                // Show feedback
                feedbackDiv.style.display = 'block';
                feedbackDiv.className = `quiz-feedback ${isCorrect ? 'success' : 'error'}`;
                feedbackDiv.innerHTML = `
                    <h3>${isCorrect ? '✓ Correct!' : '✗ Incorrect'}</h3>
                    <p>${isCorrect ? 
                        'Great job! You can proceed to the next question.' : 
                        'Not quite right. ' + questionData.explanation}</p>
                `;
                
                // Show next button
                if (nextBtn) {
                    nextBtn.style.display = 'inline-block';
                }
                
                // Disable submit button
                submitBtn.disabled = true;
                
                // Now add the help text - only add it once
                const helpText = document.createElement('div');
                helpText.className = 'help-text';
                helpText.innerHTML = `
                    <strong>Correct Answer:</strong><br>
                    ${Array.isArray(questionData.correct_answers || questionData.correct_answer) ? 
                        (questionData.correct_answers || [questionData.correct_answer]).join(', ') : 
                        (typeof questionData.correct_answers === 'object' ? 
                            Object.entries(questionData.correct_answers).map(([k,v]) => `${k} → ${v}`).join('<br>') :
                            questionData.correct_answer)
                    }<br><br>
                    <strong>Explanation:</strong><br>
                    ${questionData.explanation}
                `;
                feedbackDiv.appendChild(helpText);
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Failed to save your answer. Please try again.');
            });
        });
    }
});

// Initialize drag and drop for matching questions
if (document.querySelector('.matching-container')) {
    $(document).ready(function() {
        // Initialize draggable
        $('.technique-item').draggable({
            revert: 'invalid',
            helper: 'clone',
            cursor: 'move',
            start: function(event, ui) {
                $(this).addClass('dragging');
            },
            stop: function(event, ui) {
                $(this).removeClass('dragging');
                // Auto-save after drag operation completed
                setTimeout(saveCurrentSelections, 100);
            }
        });

        // Initialize droppable
        $('.emotion-box').droppable({
            accept: '.technique-item',
            hoverClass: 'ui-droppable-hover',
            drop: function(event, ui) {
                const $droppedItem = ui.draggable;
                const $dropZone = $(this);
                
                // Store the source and target for saving
                const technique = $droppedItem.data('technique');
                const emotion = $dropZone.data('emotion');
                console.log(`Dropping ${technique} into ${emotion}`);
                
                // If there's already an item in this box, move it back
                const $existingItem = $dropZone.find('.technique-item');
                if ($existingItem.length) {
                    $('#tech-list').append($existingItem);
                    $existingItem.css({
                        position: 'relative',
                        top: 0,
                        left: 0
                    });
                }
                
                // Remove placeholder text only, keep the emotion label
                $dropZone.find('.placeholder').remove();
                
                // Clone the dragged item if it was a helper
                let $itemToPlace;
                if (ui.helper.hasClass('ui-draggable-dragging')) {
                    // Using the original instead of the helper
                    $itemToPlace = $droppedItem;
                    // Remove from original location
                    $droppedItem.detach();
                } else {
                    $itemToPlace = $droppedItem;
                }
                
                // Move dropped item to this box, before the emotion label
                const $emotionLabel = $dropZone.find('.emotion-label');
                if ($emotionLabel.length) {
                    $itemToPlace.insertBefore($emotionLabel);
                } else {
                    $dropZone.append($itemToPlace);
                }
                
                // Reset position
                $itemToPlace.css({
                    top: 0,
                    left: 0,
                    position: 'relative'
                });
                
                // Explicitly save this match
                setTimeout(function() {
                    // Build current state of all matches
                    const matches = {};
                    $('.emotion-box').each(function() {
                        const $box = $(this);
                        const $technique = $box.find('.technique-item');
                        if ($technique.length) {
                            matches[$technique.data('technique')] = $box.data('emotion');
                        }
                    });
                    
                    console.log("Saving matches:", matches);
                    fetch('/save_progress', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            answers: {
                                [currentQuestionId]: matches
                            },
                            submitted: false
                        })
                    });
                }, 100);
            }
        });
        
        // Restore any saved matches on page load
        const savedAnswer = {{ saved_answer|tojson|safe if saved_answer else 'null' }};
        console.log("Checking for saved matches:", savedAnswer);
        
        if (savedAnswer && typeof savedAnswer === 'object') {
            // Clear any existing placements first
            $('.technique-item').each(function() {
                $('#tech-list').append($(this));
            });
            
            // Now restore the saved matches
            Object.entries(savedAnswer).forEach(([tech, emo]) => {
                const $technique = $(`.technique-item[data-technique="${tech}"]`);
                const $emotion = $(`.emotion-box[data-emotion="${emo}"]`);
                
                if ($technique.length && $emotion.length) {
                    // Remove placeholder
                    $emotion.find('.placeholder').remove();
                    
                    // Place before emotion label
                    const $emotionLabel = $emotion.find('.emotion-label');
                    if ($emotionLabel.length) {
                        $technique.insertBefore($emotionLabel);
                    } else {
                        $emotion.append($technique);
                    }
                    
                    // Reset position
                    $technique.css({
                        top: 0,
                        left: 0,
                        position: 'relative'
                    });
                    
                    console.log(`Restored match: ${tech} → ${emo}`);
                }
            });
        }
    });
}
</script>

<!-- Add this section after the quiz content to show correct answers -->
<script>
// Quiz answers helper
const quizAnswers = {
    1: {
        type: 'identify',
        correct: ['Dutch Angle', 'Low-Key Lighting'],
        explanation: 'The Dutch Angle creates disorientation while Low-Key Lighting builds atmosphere.'
    },
    2: {
        type: 'identify',
        correct: ['Handheld Camera', 'Extreme Close-Up'],
        explanation: 'Handheld camera creates unease while extreme close-ups intensify emotions.'
    },
    3: {
        type: 'match',
        correct: {
            'Dutch Angle': 'Disorientation',
            'Tracking Shot': 'Immersion',
            'Low-Key Lighting': 'Mystery',
            'Bird\'s Eye View': 'Insignificance'
        },
        explanation: 'Each technique creates a specific psychological effect on the viewer.'
    },
    4: {
        type: 'match',
        correct: {
            'Wide Angle Lens': 'Spatial Distortion',
            'Telephoto Lens': 'Compression',
            'Macro Lens': 'Extreme Detail',
            'Tilt-Shift Lens': 'Miniaturization'
        },
        explanation: 'Different lenses create distinct visual effects that serve various storytelling purposes.'
    },
    5: {
        type: 'scenario',
        correct: 'Dolly Zoom',
        explanation: 'The dolly zoom (pushing in while zooming out) creates a disorienting effect perfect for moments of revelation.'
    },
    6: {
        type: 'scenario',
        correct: 'Extreme Wide Shot',
        explanation: 'An extreme wide shot makes the character appear small and vulnerable within the vast space.'
    },
    7: {
        type: 'analysis',
        correct: ['Dutch Angle', 'Tracking Shot', 'Low-Key Lighting'],
        explanation: 'These techniques combine to create a complex and atmospheric scene.'
    },
    8: {
        type: 'analysis',
        correct: ['Steadicam Shot', 'Symmetrical Framing', 'Low Angle'],
        explanation: 'Kubrick\'s signature style combines smooth camera movement with precise composition.'
    }
};

// We don't need the click handler here, as we're using the direct question data
// from the server instead of the quizAnswers object
</script>

<!-- Check if this question was already answered and show feedback -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // We already have a more thorough initialization earlier in the file
  // This duplicate code is being removed to prevent conflicts
});
</script>

<!-- Add a specific handler for Question 1 checkbox initialization -->
<script>
// This helper function will specifically ensure Question 1 checkboxes are initialized correctly
document.addEventListener('DOMContentLoaded', function() {
  const currentQuestion = {{ current_question }};
  
  // Only run for Question 1
  if (currentQuestion === 1) {
    console.log("Special handling for Question 1 initialization");
    
    // Get the saved answers from server
    const savedAnswer = {{ saved_answer|tojson|safe if saved_answer else 'null' }};
    console.log("Question 1 saved answer:", savedAnswer);
    
    if (savedAnswer && Array.isArray(savedAnswer)) {
      // Force check the checkboxes
      savedAnswer.forEach(answer => {
        const checkbox = document.querySelector(`input[type="checkbox"][value="${answer}"]`);
        if (checkbox) {
          console.log(`Setting checkbox for ${answer} to checked`);
          checkbox.checked = true;
        } else {
          console.log(`Could not find checkbox for ${answer}`);
        }
      });
      
      // Verify checkboxes are set
      setTimeout(() => {
        const checkedBoxes = document.querySelectorAll('input[type="checkbox"]:checked');
        console.log(`After initialization, ${checkedBoxes.length} checkboxes are checked`);
        checkedBoxes.forEach(box => console.log(`- ${box.value} is checked`));
      }, 100);
    }
  }
});
</script>
{% endblock %}